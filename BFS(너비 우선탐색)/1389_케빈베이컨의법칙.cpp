// 케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 
// 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에 이어질 수 있는지 계산하는 게임이다.
// 예를 들어, BOJ의 유저가 5명이고, 1과 3, 1과 4, 2와 3, 3과 4, 4와 5가 친구인 경우를 생각해보자.

// 1은 2까지 3을 통해 2단계 만에, 3까지 1단계, 4까지 1단계, 5까지 4를 통해서 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+1+2 = 6이다.

// 2는 1까지 3을 통해서 2단계 만에, 3까지 1단계 만에, 4까지 3을 통해서 2단계 만에, 5까지 3과 4를 통해서 3단계 만에 알 수 있다. 
// 따라서, 케빈 베이컨의 수는 2+1+2+3 = 8이다.

// 3은 1까지 1단계, 2까지 1단계, 4까지 1단계, 5까지 4를 통해 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 1+1+1+2 = 5이다.

// 4는 1까지 1단계, 2까지 3을 통해 2단계, 3까지 1단계, 5까지 1단계 만에 알 수 있다. 4의 케빈 베이컨의 수는 1+2+1+1 = 5가 된다.

// 마지막으로 5는 1까지 4를 통해 2단계, 2까지 4와 3을 통해 3단계, 3까지 4를 통해 2단계, 4까지 1단계 만에 알 수 있다.
//  5의 케빈 베이컨의 수는 2+3+2+1 = 8이다.

// 5명의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람은 3과 4이다.

// BOJ 유저의 수와 친구 관계가 입력으로 주어졌을 때, 케빈 베이컨의 수가 가장 작은 사람을 구하는 프로그램을 작성하시오.

// 입력
// 첫째 줄에 유저의 수 N (2 ≤ N ≤ 100)과 친구 관계의 수 M (1 ≤ M ≤ 5,000)이 주어진다. 
// 둘째 줄부터 M개의 줄에는 친구 관계가 주어진다. 친구 관계는 A와 B로 이루어져 있으며, A와 B가 친구라는 뜻이다. 
// A와 B가 친구이면, B와 A도 친구이며, A와 B가 같은 경우는 없다. 친구 관계는 중복되어 들어올 수도 있으며, 
// 친구가 한 명도 없는 사람은 없다. 또, 모든 사람은 친구 관계로 연결되어져 있다.

// 출력
// 첫째 줄에 BOJ의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 출력한다. 그런 사람이 여러 명일 경우에는 번호가 가장 작은 사람을 출력한다.

#include <stdio.h>
#include <vector>
#include <queue>
#include <algorithm>
#pragma warning (disable:4996)
using namespace std;

int main()
{
	int sum_fin[102] = { 0, };
	int min = 0;
	int min_num = 0;
	int n, m;
	int mate[102][102] = { 0, };
	scanf("%d %d", &n, &m);
	for (int i = 0; i < m; i++)
	{
		int a, b;
		scanf("%d %d", &a, &b);
		mate[a][b] = 1;
		mate[b][a] = 1;
	}
	for (int i = 1; i <= n; i++)
	{
		int start = i;
		int visit[102] = { 0, };
		int sum[102] = { 0, };
		queue <int> q;
		q.push(start);
		while (!q.empty()) {
			int now = q.front();
			q.pop();
			for (int j = 1; j <= n; j++)
			{
				if (mate[now][j] == 1 && visit[j] == 0 )
				{
					visit[j] = 1;
					q.push(j);
					sum[j] = sum[now] + 1;
				}
			}

		}
		for (int k = 1; k <= n; k++)
		{
			sum_fin[i] += sum[k];
		}
		if (i == 1)
		{
			min = sum_fin[i];
			min_num = i;
		}
		else
		{
			if (min > sum_fin[i])
			{
				min = sum_fin[i];
				min_num = i;
			}
			
		}
		
	}
	printf("%d", min_num);
}